
# C++中的虚函数是用来干什么的


# 多线程和多进程的区别


# 32位和64位操作系统编程的区别


CPU一次可处理的数据大小区别，这影响操作系统所支持的内存寻址地址大小、以及相关的运算器、寄存器等硬件的所支持处理的数据大小，进而导致64位的操作系统可以支持更大的文件和内外存的存储空间。

32位操作系统的内存限制为4GB，它只能对2^32个字节的内存进行地址分配。这限制了32位操作系统在处理需要大量内存的任务时的性能。

64位操作系统则没有这个限制，它可以对更大的内存进行地址分配，因此能够更有效地处理大型的数据和任务。

# C++中malloc/free 和new/delete的区别


# 指针和引用的区别

# int与unsigned int之间的运算与比较


int 会转成unsigned int 不过需要源码 补码 
[(33条消息) int与unsigned int之间的运算与比较_int和unsigned int比较_西南小镇的博客-CSDN博客](https://blog.csdn.net/u012675103/article/details/45953183)

[(33条消息) 【C++】两个例子解决 unsigned int 与 int 运算问题_RiceVan的博客-CSDN博客](https://blog.csdn.net/RiceVan/article/details/108336848)

# shell命令

[shell脚本]([一篇教会你写90%的shell脚本 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/264346586))


# 二叉树递归

**如果需要搜索整棵二叉树，那么递归函数就不要返回值，如果要搜索其中一条符合条件的路径，递归函数就需要返回值，因为遇到符合条件的路径了就要及时返回。**

如果递归函数有返回值，如何区分要搜索一条边，还是搜索整个树呢？

搜索一条边的写法：
```
if (递归函数(root->left)) return ;

if (递归函数(root->right)) return ;
```
搜索整个树写法：
```
left = 递归函数(root->left);  // 左
right = 递归函数(root->right); // 右
left与right的逻辑处理;         // 中 
```
看出区别了没？

**在递归函数有返回值的情况下：如果要搜索一条边，递归函数返回值不为空的时候，立刻返回，如果搜索整个树，直接用一个变量left、right接住返回值，这个left、right后序还有逻辑处理的需要，也就是后序遍历中处理中间节点的逻辑（也是回溯）**。

那么为什么要遍历整棵树呢？直观上来看，找到最近公共祖先，直接一路返回就可以了。

**那么我给大家归纳如下三点**：

求最小公共祖先，需要从底向上遍历，那么二叉树，只能通过后序遍历（即：回溯）实现从底向上的遍历方式。

在回溯的过程中，必然要遍历整棵二叉树，即使已经找到结果了，依然要把其他节点遍历完，因为要使用递归函数的返回值（也就是代码中的left和right）做逻辑判断。

要理解如果返回值left为空，right不为空为什么要返回right，为什么可以用返回right传给上一层结果。



# 指针常量 常量指针

常量指针：const int * p （底层const）
指针常量 int * const p （顶层const）


![image](https://cdn.staticaly.com/gh/andyye1999/picx-images-hosting@master/20230511/image.2xrwxuw0g500.webp)

# 大顶堆 优先队列

[剑指 Offer 41. 数据流中的中位数](https://leetcode.cn/problems/shu-ju-liu-zhong-de-zhong-wei-shu-lcof)

[347. 前 K 个高频元素](https://leetcode.cn/problems/top-k-frequent-elements)

[239. 滑动窗口最大值](https://leetcode.cn/problems/sliding-window-maximum) 单调队列或者优先队列  

[23. 合并K个排序链表](https://leetcode.cn/problems/merge-k-sorted-lists)



```cpp
less<int> // 大顶堆
greater<int> // 小顶堆 
priority_queue<int,vector<int>,less<int>> maxHeap;
```

要么
```cpp
struct cmp
{
	bool operator()(int a,int b)
	{
		return a < b;  // 大顶堆
	}
};
```

而且 是 top 不是 front
# 万能头文件 

```cpp
#include <bits/stdc++.h>
```

# 排序

冒泡排序：从左到右遍历，两两比较大小并交换位置，一次遍历下来后最右侧为最值

快速排序：一次遍历后，数组被分为＜=num和＞num的两部分，递推执行

归并排序：递归的分裂数组，然后进行小子序列的排序，然后将有序的子序列进行归并，最终得到完全有序的序列

# ASCII码

[ASCII码一览表，ASCII码对照表 (biancheng.net)](http://c.biancheng.net/c/ascii/)

小写字母比大写字母大
大写字母+32等于小写字母  

A 65 a 97 0：48
# 向上取整 向下取整

[(31条消息) 取整函数（ceil、floor、round）_aouixh的博客-CSDN博客](https://blog.csdn.net/aouixh/article/details/53483556)

ceil 天花板的意思 向上取整  
floor  地板 向下取整 



# 全局变量和局部变量能重复吗

```cpp
1. #include <stdio.h>

3. int n = 10;  //全局变量

5. void func1(){
6.     int n = 20;  //局部变量
7.     printf("func1 n: %d\n", n);
8. }

10. void func2(int n){
11.     printf("func2 n: %d\n", n);
12. }

14. void func3(){
15.     printf("func3 n: %d\n", n);
16. }

18. int main(){
19.     int n = 30;  //局部变量
20.     func1();
21.     func2(n);
22.     func3();
23.     //代码块由{}包围
24.     {
25.         int n = 40;  //局部变量
26.         printf("block n: %d\n", n);
27.     }
28.     printf("main n: %d\n", n);

30.     return 0;
31. }
```

运行结果：  
func1 n: 20  
func2 n: 30  
func3 n: 10  
block n: 40  
main n:  30  


代码中虽然定义了多个同名变量 n，但它们的作用域不同，在内存中的位置（地址）也不同，所以是相互独立的变量，互不影响，不会产生`重复定义（Redefinition）`错误。  
  
1) 对于 func1()，输出结果为 20，显然使用的是函数内部的 n，而不是外部的 n；func2() 也是相同的情况。  
  
当全局变量和局部变量同名时，在局部范围内全局变量被“屏蔽”，不再起作用。或者说，变量的使用遵循就近原则，如果在当前作用域中存在同名变量，就不会向更大的作用域中去寻找变量。  
  
2) func3() 输出 10，使用的是全局变量，因为在 func3() 函数中不存在局部变量 n，所以编译器只能到函数外部，也就是全局作用域中去寻找变量 n。  
  
3) 由`{ }`包围的代码块也拥有独立的作用域，printf() 使用它自己内部的变量 n，输出 40。  
  
4) C语言规定，只能从小的作用域向大的作用域中去寻找变量，而不能反过来，使用更小的作用域中的变量。对于 main() 函数，即使代码块中的 n 离输出语句更近，但它仍然会使用 main() 函数开头定义的 n，所以输出结果是 30。

# 排序算法

[1.0 十大经典排序算法 | 菜鸟教程 (runoob.com)](https://www.runoob.com/w3cnote/ten-sorting-algorithm.html)

[【C++】十大排序（冒泡、选择、插入、希尔、归并、快排、堆、计数、桶、基数） - 排序数组 - 力扣（LeetCode）](https://leetcode.cn/problems/sort-an-array/solution/by-peaceful-thompsonfsu-b3bu/)


常见的内部排序算法有：插入排序、希尔排序、选择排序、冒泡排序、归并排序、快速排序、堆排序、基数排序等。用一张图概括：

![](https://www.runoob.com/wp-content/uploads/2019/03/sort.png)

点击以下图片查看大图：

[![](https://www.runoob.com/wp-content/uploads/2019/03/0B319B38-B70E-4118-B897-74EFA7E368F9.png)](https://www.runoob.com/wp-content/uploads/2019/03/0B319B38-B70E-4118-B897-74EFA7E368F9.png)
# 对于一个已经大部分排序的数组用哪种排序方法好

插入排序

# STL中的sort

[C++一道深坑面试题：STL里sort算法用的是什么排序算法？ - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/36274119)

STL的sort算法，数据量大时采用**QuickSort快排算法**，分段归并排序。一旦分段后的数据量小于某个门槛（16），为避免QuickSort快排的递归调用带来过大的额外负荷，就改用**Insertion Sort插入排序**。如果递归层次过深，还会改用**HeapSort堆排序**。

![](https://pic1.zhimg.com/80/v2-8fa032e195365f77fb6b980a4ed71958_720w.webp)

# 为什么前序和后序不能确定二叉树

**前序和后序在本质上都是将父节点与子结点进行分离,但并没有指明左子树和右子树的能力,因此得到这两个序列只能明确父子关系, 而不能确定一个二叉树**。

# 位运算

剑指15 n&(n−1) 求该数二进制有多少个1

`int rightonr = n & (~n + 1)`  提取出最右的1
# **extern "C"**

C++来说，支持函数的重载，编译后的函数一般是以函数名和形参类型来命名的。

例如函数**void fun(int, int)，编译后的可能是_fun_int_int(不同编译器可能不同，但都采用了类似的机制，用函数名和参数类型来命名编译后的函数名)；而C语言没有类似的重载机制，一般是利用函数名来指明编译后的函数名的，对应上面的函数可能会是_fun这样的名字。**

# 异或

![image](https://cdn.staticaly.com/gh/andyye1999/picx-images-hosting@master/20230709/image.2e9dh7q308ys.webp)



# define和const有什么区别？


- 编译器处理方式不同：`#define`宏是在**预处理**阶段展开，不能对宏定义进行调试，而`const`常量是在**编译**阶段使用；
- 类型和安全检查不同：`#define`宏没有类型，不做任何类型检查，仅仅是代码展开，可能产生边际效应等错误，而`const`常量有具体类型，在编译阶段会执行**类型**检查；
- 存储方式不同：`#define`宏仅仅是代码展开，在多个地方进行字符串替换，**不会分配内存**，存储于程序的代码段中，而`const`常量会**分配内存**，但只维持一份拷贝，存储于程序的数据段中。
- 定义域不同：`#define`宏不受定义域限制，而`const`常量只在定义域内有效。


# 指针和引用的区别

非空区别： 引用必须指向某些对象
使用sizeof看一个指针的大小是4，而引用则是被引用对象的大小；
可修改区别 指针可以被重新赋值指向另一个不同的对象 引用总是指向在初始化时指定的对象

使用sizeof看一个指针的大小是4，而引用则是被引用对象的大小；
指针可以有多级指针（**p），而引用止于一级

# 组合 排列 子集

46全排列
77组合
78子集

# 背包问题

问能否能装满背包（或者最多装多少）：dp[j] = max(dp[j], dp[j - nums[i]] + nums[i]);

```cpp
void test_1_wei_bag_problem() {
    vector<int> weight = {1, 3, 4};
    vector<int> value = {15, 20, 30};
    int bagWeight = 4;

    // 初始化
    vector<int> dp(bagWeight + 1, 0);
    for(int i = 0; i < weight.size(); i++) { // 遍历物品
        for(int j = bagWeight; j >= weight[i]; j--) { // 遍历背包容量
            dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);
        }
    }
    cout << dp[bagWeight] << endl;
}
```
416 1049
问装满背包有几种方法：dp[j] += dp[j - nums[i]]
**如果求组合数就是外层for循环遍历物品，内层for遍历背包**。

**如果求排列数就是外层for遍历背包，内层for循环遍历物品**。
494 518 377 
问装满背包所有物品的最小个数：dp[j] = min(dp[j - coins[i]] + 1, dp[j]);

322 279

# 浮点数



[2.7 为什么 0.1 + 0.2 不等于 0.3 ？ | 小林coding (xiaolincoding.com)](https://xiaolincoding.com/os/1_hardware/float.html#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%B4%9F%E6%95%B0%E8%A6%81%E7%94%A8%E8%A1%A5%E7%A0%81%E8%A1%A8%E7%A4%BA)

某个32位浮点数，符号位1位，指数位8位，尾数部分23位，问该浮点数最大能表述的正数是多少？
一个32位浮点数遵循IEEE 754标准，其结构如下：  
  
- 符号位（1位）：表示正数（0）或负数（1）  
- 指数位（8位）：表示指数的偏移值  
- 尾数部分（23位）：表示有效数字的小数部分  
  
要计算32位浮点数能表示的最大正数，我们需要考虑以下因素：  
  
1. 符号位为0，表示正数。  
2. 指数位的最大值为11111110（二进制），因为全1（11111111）是保留给特殊值（例如无穷大和NaN）的。所以，最大指数值为254（十进制），但需要减去偏移值127，得到实际最大指数127。  
3. 尾数部分的最大值为全1（11111111111111111111111，二进制）。将这个二进制数转换为十进制小数，我们得到1 - 2^{-23}。  
  
根据以上信息，我们可以计算出32位浮点数能表示的最大正数：  
  
最大正数 = (1 + 尾数部分最大值) * 2^{最大指数}  
  
最大正数 = (1 + (1 - 2^{-23})) * 2^{127}  
  
最大正数 ≈ 3.4028235 * 10^{38}

# 设计模式

装饰器模式在不改变对象自身的基础上，在程序运行期间给对象动态的添加职责（方法或属性）

# map 和 unordered_map区别


  
map 
底层采用**红黑树**实现，红黑树具有自动排序的功能，因此 map 内部的所有元素都是有序的，红黑树的每一个节点都代表着 map 的一个元素。对于 map 进行的查找、删除、添加等一系列的操作都相当于是对红黑树进行的操作。 
unordered_map
unordered_map 内部实现了一个**哈希表**，其元素的排列顺序是无序的。

map
   
优点：有序性，其元素的**有序性**在很多应用中都会简化很多的操作；底层适用红黑树实现，因此效率非常的高  
缺点： 空间占用率高，因为 map 内部实现了红黑树，虽然提高了运行效率，但是因为每一个节点都需要额外保存父节点、孩子节点和红/黑性质，使得每一个节点都占用大量的空间
适用场景：对于那些有顺序要求的问题，用 map 会更高效一些

unordered_map  
优点： 内部实现了哈希表，因此其**查找速度非常的快**  
缺点： 哈希表的建立比较耗费时间  
适用处：对于查找问题，unordered_map 会更加高效一些

# 虚继承

解决菱形继承问题

# C和C++有什么区别？

- C++是面向对象的语言，而C是面向过程的语言；
- C++引入`new/delete`运算符，取代了C中的`malloc/free`库函数；
- C++引入引用的概念，而C中没有；
- C++引入类的概念，而C中没有；
- C++引入函数重载的特性，而C中没有

# static关键字有什么作用？


[掌握C++中static关键字的多种使用场景 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/602473872)

- 修饰**局部变量时**，使得该变量在**静态存储区**分配内存；只能在首次函数调用中进行首次初始化，之后的函数调用**不再进行初始化**；其生命周期与程序相同，但其作用域为局部作用域，并不能一直被访问；
- 修饰**全局变量**时，使得该变量在静态存储区分配内存；在声明该变量的整个文件中都是可见的，而在**文件外是不可见的**；
- 修饰**函数**时，在声明该函数的整个文件中都是可见的，而在**文件外是不可见的**，从而可以在多人协作时避免同名的函数冲突；
- 修饰**成员变量**时，所有的对象都只维持一份拷贝，可以实现不同对象间的数据共享；不需要实例化对象即可访问；**不能在类内部初始化**，一般在类外部初始化，并且初始化时不加`static`； [C++ 类的静态成员 | 菜鸟教程 (runoob.com)](https://www.runoob.com/cplusplus/cpp-static-members.html)
- 修饰**成员函数**时，该函数不接受`this`指针，只能访问类的静态成员；不需要实例化对象即可访问

# define和const有什么区别？

- 编译器处理方式不同：`#define`宏是在**预处理阶段**展开，不能对宏定义进行调试，而`const`常量是在**编译**阶段使用；
- 类型和安全检查不同：`#define`宏**没有类型**，**不做任何类型检查**，仅仅是代码展开，可能产生边际效应等错误，而`const`常量有**具体类型**，在编译阶段会**执行类型检查**；
- 存储方式不同：`#define`宏仅仅是代码展开，在多个地方进行字符串替换，**不会分配内存**，存储于程序的代码段中，而`const`常量**会分配内存**，但只维持一份拷贝，存储于程序的数据段中。
- 定义域不同：`#define`宏不受定义域限制，而`const`常量只在定义域内有效。

# typedef 和define 有什么区别

- 用法不同：typedef 用来定义一种数据类型的别名，增强程序的可读性。define 主要用来定义 常量，以及书写复杂使用频繁的宏。
- 执行时间不同：typedef 是编译过程的一部分，有类型检查的功能。define 是宏定义，是预编译的部分，其发生在编译之前，只是简单的进行字符串的替换，不进行类型的检查。
- 作用域不同：typedef 有作用域限定。define 不受作用域约束，只要是在define 声明后的引用 都是正确的。
- 对指针的操作不同：typedef 和define 定义的指针时有很大的区别。

**「注意」**：typedef 定义是语句，因为句尾要加上分号。而define 不是语句，千万不能在句尾加分号。



# 变量的声明和定义有什么区别

变量的定义为变量分配地址和存储空间， 变量的声明不分配地址。一个变量可以在多个地方声明， 但是只在一个地方定义。加入extern 修饰的是变量的声明，说明此变量将在文件以外或在文件后面部分定义。

说明：很多时候一个变量，只是声明不分配内存空间，直到具体使用时才初始化，分配内存空间， 如外部变量。

# 结构体可以直接赋值吗

声明时可以直接初始化，同一结构体的不同对象之间也可以直接赋值，但是当结构体中含有指针“成员”时一定要小心。

# sizeof 和strlen 的区别

- sizeof是一个操作符，strlen是库函数。
- sizeof的参数可以是数据的类型，也可以是变量，而strlen只能以结尾为‘\0’的字符串作参数。
- 编译器在编译时就计算出了sizeof的结果，而strlen函数必须在运行时才能计算出来。并且sizeof计算的是数据类型占内存的大小，而strlen计算的是字符串实际的长度。
- 数组做sizeof的参数不退化，传递给strlen就退化为指针了

# C 语言的关键字 static 和 C++ 的关键字 static 有什么区别

在 C 中 static 用来修饰局部静态变量和外部静态变量、函数。而 C++中除了上述功能外，还用来定义类的成员变量和函数。即静态成员和静态成员函数。

**「注意」**：编程时 static 的记忆性，和全局性的特点可以让在不同时期调用的函数进行通信，传递信息，而 C++的静态成员则可以在多个对象实例间进行通信，传递信息。

# 全局变量和局部变量有什么区别？操作系统和编译器是怎么知道的？

- 全局变量是整个程序都可访问的变量，谁都可以访问，生存期在整个程序从运行到结束（在程序结束时所占内存释放）；
- 而局部变量存在于模块（子程序，函数）中，只有所在模块可以访问，其他模块不可直接访问，模块结束（函数调用完毕），局部变量消失，所占据的内存释放。
- 操作系统和编译器，可能是通过内存分配的位置来知道的，全局变量分配在**全局数据段**并且在程序开始运行的时候被加载.局部变量则分配在堆栈里面。

# 指针和引用的区别

- 指针有自己的**一块空间**，而引用只是一个别名；
- 使用sizeof看一个指针的大小是4，而引用则是被引用对象的大小；
- 作为参数传递时，指针需要被解引用才可以对对象进行操作，而直接对引 用的修改都会改变引用所指向的对象；
- 可以有const指针，但是没有const引用；（具体解释看评论区）
- 指针在使用中可以指向其它对象，但是引用只能是一个对象的引用，不能 被改变；
- 指针可以有多级指针（**p），而引用止于一级；
- 指针和引用使用++运算符的意义不一样；
- 如果返回动态内存分配的对象或者内存，必须使用指针，引用可能引起内存泄露。

# 结构体和类的区别

- C语言的结构体是不能有函数成员的，而C++的类可以有。
- C语言的结构体中数据成员是没有private、public和protected访问限定的。而C++的类的成员有这些访问限定。
- C语言的结构体是没有继承关系的，而C++的类却有丰富的继承关系。

**「注意」**：虽然C的结构体和C++的类有很大的相似度，但是类是实现面向对象的基础。而结构体只可以简单地理解为类的前身。




# 简述C++/C从代码到可执行二进制文件的过程

C++和C语言类似，一个C++程序从源码到执行文件，有四个过程，**预编译、编译、汇编、链接**。

1. 预编译：这个过程主要的处理操作如下：

   （1） 将所有的#define删除，并且展开所有的宏定义

   （2） 处理所有的条件预编译指令，如#if、#ifdef

   （3） 处理#include预编译指令，将被包含的文件插入到该预编译指令的位置。

   （4） 过滤所有的注释

   （5） 添加行号和文件名标识。

2. 编译：这个过程主要的处理操作如下：

   （1） 词法分析：将源代码的字符序列分割成一系列的记号。

   （2） 语法分析：对记号进行语法分析，产生语法树。

   （3） 语义分析：判断表达式是否有意义。

   （4） 代码优化：

   （5） 目标代码生成：生成汇编代码。

   （6） 目标代码优化：

3. 汇编：这个过程主要是将汇编代码转变成机器可以执行的指令。

4. 链接：将不同的源文件产生的目标文件进行链接，从而形成一个可以执行的程序。

# 静态链接和动态链接
   链接分为静态链接和动态链接。


   静态链接，是在链接的时候就已经把要调用的函数或者过程链接到了生成的可执行文件中，就算你在去把静态库删除也不会影响可执行程序的执行；生成的静态链接库，Windows下以.lib为后缀，Linux下以.a为后缀。

   而动态链接，是在链接的时候没有把调用的函数代码链接进去，而是在执行的过程中，再去找要链接的函数，生成的可执行文件中没有函数代码，只包含函数的重定位信息，所以当你删除动态库时，可执行程序就不能运行。生成的动态链接库，Windows下以.dll为后缀，Linux下以.so为后缀。


# 三大特性

- 封装：将客观事物封装成抽象的类，而类可以把自己的数据和方法暴露给可信的类或者对象，对不可信的类或对象则进行信息隐藏。
- 继承：可以使用现有类的所有功能，并且无需重新编写原来的类即可对功能进行拓展；
- 多态：一个类实例的相同方法在不同情形下有不同的表现形式，使不同内部结构的对象可以共享相同的外部接口。

# 类成员访问权限

C++通过 public、protected、private 三个关键字来控制成员变量和成员函数的访问权限，它们分别表示公有的、受保护的、私有的，被称为成员访问限定符。在类的内部（定义类的代码内部），无论成员被声明为 public、protected 还是 private，都是可以互相访问的，没有访问权限的限制。在类的外部（定义类的代码之外），只能通过对象访问成员，并且通过对象只能访问 public 属性的成员，不能访问 private、protected 属性的成员

# 多态的实现方式

多态分为**静态多态和动态多态**。其中，**静态多态**是通过**重载和模板**技术实现的，在**编译期间**确定；**动态多态**是通过**虚函数和继承**关系实现的，执行动态绑定，在**运行期间**确定。

# 动态绑定是如何实现的？

当编译器发现类中有虚函数时，会创建一张**虚函数表**，把虚函数的函数入口地址放到虚函数表中，并且在对象中增加**一个指针`vptr`**，用于**指向类的虚函数表**。当派生类覆盖基类的虚函数时，**会将虚函数表中对应的指针进行替换**，从而调用派生类中覆盖后的虚函数，从而实现动态绑定。

# 动态多态有什么作用？有哪些必要条件？

动态多态的作用：

- 隐藏实现细节，使代码模块化，提高代码的可复用性；
- 接口重用，使派生类的功能可以被基类的指针/引用所调用，即向后兼容，提高代码的可扩充性和可维护性。

动态多态的必要条件：

- 需要有继承；
- 需要有虚函数覆盖；
- 需要有基类指针/引用指向子类对象

# 纯虚函数有什么作用？如何实现？
定义纯虚函数是为了实现一个接口，起到规范的作用，想要继承这个类就必须覆盖该函数。

**实现方式**是在虚函数声明的结尾加上`= 0`即可。

# 虚函数表是针对类的还是针对对象的？同一个类的两个对象的虚函数表是怎么维护的？

虚函数表是**针对类**的，**类的所有对象共享这个类的虚函数表**，因为**每个对象内部都保存一个指向该类虚函数表的指针`vptr`，每个对象的`vptr`的存放地址都不同，但都指向同一虚函数表。**

# 为什么基类的构造函数不能定义为虚函数？

虚函数的调用依赖于**虚函数表**，而指向虚函数表的指针`vptr`需要在构造函数中进行**初始化**，所以无法调用定义为虚函数的构造函数。因为创建一个对象时需要确定对象的类型，而虚函数是在运行时确定其类型的。

# 为什么基类的析构函数需要定义为虚函数？

为了实现动态绑定，基类指针指向派生类对象，如果析构函数不是虚函数，那么在对象销毁时，就会调用基类的析构函数，只能销毁派生类对象中的部分数据，所以必须将析构函数定义为虚函数，从而在对象销毁时，调用派生类的析构函数，从而销毁派生类对象中的所有数据。

# 构造函数和析构函数能抛出异常吗？

- 从语法的角度来说，构造函数可以抛出异常，但从逻辑和风险控制的角度来说，尽量不要抛出异常，否则可能导致内存泄漏。
- **析构函数不可以抛出异常**，如果析构函数抛出异常，则异常点之后的程序，比如释放内存等操作，就不会被执行，从而造成**内存泄露**的问题；而且当异常发生时，C++通常会调用对象的析构函数来释放资源，如果此时析构函数也抛出异常，即前一个异常未处理又出现了新的异常，从而造成程序崩溃的问题。

# 如何让一个类不能实例化？

将类定义为**抽象类**（也就是**存在纯虚函数**）
或者将构造函数声明为`private`。

# 多继承存在什么问题？如何消除多继承中的二义性？

1. 增加程序的复杂度，使得程序的编写和维护比较困难，容易出错；
    
2. 在继承时，基类之间或基类与派生类之间发生成员同名时，将出现对成员访问的不确定性，即同名二义性；

消除同名二义性的方法：

- **利用作用域运算符`::`**，用于限定派生类使用的是哪个基类的成员；
- 在派生类中定义同名成员，覆盖基类中的相关成员；

3. 当派生类从多个基类派生，而这些基类又从同一个基类派生，则在访问此共同基类的成员时，将产生另一种不确定性，即路径二义性；
    
    消除路径二义性的方法：
    

- 消除同名二义性的两种方法都可以；
- 使用虚继承，使得不同路径继承来的同名成员在内存中只有一份拷贝。

# 覆盖和重载之间有什么区别？

- 覆盖是指**派生类中**重新定义的函数，**其函数名、参数列表、返回类型与父类完全相同，只是函数体存在区别；覆盖只发生在类的成员函数中**；
- 重载是指两个函数具有**相同的函数名**，**不同**的**参数列表**，**不关心返回值**；当调用函数时，根据传递的参数列表来判断调用哪个函数；重载可以是类的成员函数，也可以是普通函数。

# 对虚函数和多态的理解

多态的实现主要分为**静态多态**和**动态多态**，**静态多态**主要是**重载**，在编译的时候就已经确定；**动态多态**是用**虚函数机制**实现的，在运行期间动态绑定。举个例子：一个父类类型的指针指向一个子类对象时候，使用父类的指针去调用子类中重写了的父类中的虚函数的时候，会调用子类重写过后的函数，在父类中声明为加了virtual关键字的函数，在子类中重写时候不需要加virtual也是虚函数。

虚函数的实现：在有虚函数的类中，类的最开始部分是一个虚函数表的指针，这个指针指向一个虚函数表，表中放了虚函数的地址，实际的虚函数在代码段(.text)中。当子类继承了父类的时候也会继承其虚函数表，当子类重写父类中虚函数时候，会**将其继承到的虚函数表中的地址替换为重新写的函数地址**。使用了虚函数，会**增加访问内存开销，降低效率**。

# 请你来说一下C++中struct和class的区别

在C++中，class和struct做类型定义如下区别：

- 默认继承权限不同，**class继承默认是private继承，而struct默认是public继承**
- class还可用于定义模板参数，像typename，但是关键字struct不能用于定义模板参数

C++保留struct关键字，主要有如下原因

- 保证与C语言的向下兼容性，C++必须提供一个struct
- C++中的struct定义必须百分百地保证与C语言中的struct的向下兼容性，把C++中的最基本的对象单元规定为class而不是struct，就是为了避免各种兼容性要求的限制
- 对struct定义的扩展使C语言的代码能够更容易的被移植到C++中

# C++的空类有哪些成员函数

- 缺省构造函数。
- 缺省拷贝构造函数。
- 析构函数。
- 赋值运算符。

# new/delete和malloc/free之间有什么关系？

```cpp
int *p = new int[2];
int *q = (int *)malloc(2*sizeof(int));
```

- new与delete直接**带具体类型的指针**，malloc和free返回**void类型**的指针。
- new分配内存失败后，会抛出bac_alloc异常，malloc返回NULL
- new类型是安全的，而malloc不是。例如int *p = new float[2];就会报错；而int p = malloc(2sizeof(int))编译时编译器就无法指出错误来。
- new一般分为两步：new操作和构造。new操作对应与malloc，但new操作可以重载，可以自定义内存分配策略，不做内存分配，甚至分配到非内存设备上，而malloc不行。
- new**调用构造函数**，malloc不能；delete**调用析构函数**，而free不能。
- malloc/free需要库文件stdlib.h的支持，new/delete则不需要！，是运算符

**「注意」**：delete和free被调用后，内存不会立即回收，指针也不会指向空，delete或free仅仅是告诉操作系统，这一块内存被释放了，可以用作其他用途。但是由于没有重新对这块内存进行写操作，所以内存中的变量数值并没有发生变化，出现野指针的情况。因此，释放完内存后，应该讲该指针指向NULL。

![image](https://cdn.staticaly.com/gh/andyye1999/picx-images-hosting@master/20230620/image.428ou86aodk0.webp)

# delete与delete []有什么区别？

[C++中 delete 和 delete[] 的区别 - 爱简单的Paul - 博客园 (cnblogs.com)](https://www.cnblogs.com/simplepaul/p/6861210.html#:~:text=C%2B%2B%E4%B8%AD%20delete%20%E5%92%8C%20delete%20%5B%5D%20%E7%9A%84%E5%8C%BA%E5%88%AB%20%E5%BD%93%E8%B0%83%E7%94%A8delete%E7%9A%84%E6%97%B6%E5%80%99%EF%BC%8C%E7%B3%BB%E7%BB%9F%E4%BC%9A%E8%87%AA%E5%8A%A8%E8%B0%83%E7%94%A8%E5%B7%B2%E5%88%86%E9%85%8D%E7%9A%84%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%E3%80%82,%E5%BD%93%E6%88%91%E4%BB%AC%E7%94%A8new%20%5B%5D%20%E5%88%86%E9%85%8D%E7%9A%84%E5%AF%B9%E8%B1%A1%E6%98%AF%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E6%97%B6%EF%BC%8C%E7%94%A8delete%E5%92%8Cdelete%20%5B%5D%20%E6%B2%A1%E6%9C%89%E5%8C%BA%E5%88%AB%E3%80%82%20%E4%BD%86%E6%98%AF%EF%BC%8C%E5%BD%93%E5%88%86%E9%85%8D%E7%9A%84%E5%AF%B9%E8%B1%A1%E6%98%AF%E8%87%AA%E5%AE%9A%E4%B9%89%E5%AF%B9%E8%B1%A1%E6%97%B6%EF%BC%8C%E4%BA%8C%E8%80%85%E4%B8%8D%E8%83%BD%E9%80%9A%E7%94%A8%E3%80%82%20%E4%B8%80%E8%88%AC%E6%9D%A5%E8%AF%B4%E4%BD%BF%E7%94%A8new%E5%88%86%E9%85%8D%E7%9A%84%E5%AF%B9%E8%B1%A1%EF%BC%8C%E7%94%A8delete%E6%9D%A5%E9%87%8A%E6%94%BE%E3%80%82)

对于简单类型来说，使用`new`分配后，不管是数组数组还是非数组形式，两种方式都可以释放内存

对于自定义类型来说，就需要对于单个对象使用`delete`，对于**对象数组**使用`delete []`，**逐个调用数组中对象的析构函数**，从而释放所有内存；

如果反过来使用，即对于单个对象使用`delete []`，对于对象数组使用`delete`，其行为是未定义的；
所以，最恰当的方式就是如果用了`new`，就用`delete`；如果用了`new []`，就用`delete []`。

```cpp
#include <iostream>
using namespace std;
/////////class Babe
class Babe
{
public:
    Babe()
    {
        cout << \"Create a Babe to talk with me\" << endl;
    }
    ~Babe()
    {
        cout << \"Babe don\'t Go away,listen to me\" << endl;
    }
};
//////////main function
int main()
{
    Babe* pbabe = new Babe[3];
    delete pbabe;
    pbabe = new Babe[3];
    delete pbabe[];
    return 0;
}
```


# 内存泄漏的场景有哪些？

`malloc`和`free`未成对出现；`new/new []`和`delete/delete []`未成对出现；

在堆中创建对象分配内存，但未显式释放内存；比如，通过局部分配的内存，未在调用者函数体内释放：

```cpp
char* getMemory() {
    char *p = (char *)malloc(30);
    return p;
}
int main() {
    char *p = getMemory();
    return 0;
}
```


在构造函数中动态分配内存，但未在析构函数中正确释放内存；

未定义拷贝构造函数或未重载赋值运算符，从而造成两次释放相同内存的做法；比如，类中包含指针成员变量，在未定义拷贝构造函数或未重载赋值运算符的情况下，编译器会调用默认的拷贝构造函数或赋值运算符，以逐个成员拷贝的方式来复制指针成员变量，使得两个对象包含指向同一内存空间的指针，那么在释放第一个对象时，析构函数释放该指针指向的内存空间，在释放第二个对象时，析构函数就会释放同一内存空间，这样的行为是错误的；

没有将基类的析构函数定义为虚函数。

# 内存的分配方式有几种？

- 在**栈**上分配：在执行函数时，**局部变量**的内存都可以在栈上分配，函数结束时会自动释放；栈内存的分配运算内置于处理器的指令集中，效率很高，但分配的内存容量有限；
- 从**堆**上分配：就是那些由 new分配的内存块，他们的释放编译器不去管，由我们的应用程序去控制，一般一个new就要对应一个 delete。如果程序员没有释放掉，那么在程序结束后，操作系统会自动回收
- 从自由存储区分配：如果说堆是操作系统维护的一块内存，那么自由存储区就是C++中通过new和delete动态分配和释放对象的抽象概念。需要注意的是，自由存储区和堆比较像，但不等价
- 从**常量存储区**分配：特殊的存储区，存放的是常量，不可修改；
- 从**全局/静态存储区**分配：**全局变量和静态变量**被分配到同一块内存中，在以前的C语言中，全局变量和静态变量又分为初始化的和未初始化的，在C++里面没有这个区分了，它们共同占用同一块内存区，在该区定义的变量若没有初始化，则会被自动初始化，例如int型变量自动初始为0

# 堆和栈有什么区别？

- 分配和管理方式不同：
    - 堆是**动态分配**的，其空间的分配和释放都由程序员控制；
    - 栈是由**编译器自动管理**的，其分配方式有两种：静态分配由编译器完成，比如局部变量的分配；动态分配由`alloca()`函数进行分配，但是会由编译器释放；
- 产生碎片不同：
    - 对堆来说，频繁使用`new/delete`或者`malloc/free`会造成内存空间的不连续，产生大量碎片，是程序效率降低；
    - 对栈来说，不存在碎片问题，因为栈具有先进后出的特性；
- 生长方向不同：
    - 堆是向着内存地址增加的方向增长的，从内存的**低地址向高地址**方向增长；
    - 栈是向着内存地址减小的方向增长的，从内存的**高地址向低地址**方向增长；
- 申请大小限制不同：
    - 栈顶和栈底是预设好的，大小固定；
    - 堆是不连续的内存区域，其大小可以灵活调整

# 静态内存分配和动态内存分配有什么区别？

- 静态内存分配是在编译时期完成的，不占用CPU资源；动态内存分配是在运行时期完成的，分配和释放需要占用CPU资源；
- 静态内存分配是在栈上分配的；动态内存分配是在堆上分配的；
- 静态内存分配不需要指针或引用类型的支持；动态内存分配需要；
- 静态内存分配是按计划分配的，在编译前确定内存块的大小；动态内存分配是按需要分配的；
- 静态内存分配是把内存的控制权交给了编译器；动态内存分配是把内存的控制权给了程序员；
- 静态内存分配的运行效率比动态内存分配高，动态内存分配不当可能造成内存泄漏。

# 如何构造一个类，使得只能在堆上或只能在栈上分配内存？

- 只能在堆上分配内存：将析构函数声明为`private`；
- 只能在栈上生成对象：将`new`和`delete`重载为`private`。

# 浅拷贝和深拷贝有什么区别？

浅拷贝只复制指向某个对象的指针，而不复制对象本身，新旧对象还是共享一块内存；而深拷贝会创造一个相同的对象，新对象与原对象不共享内存，修改新对象不会影响原对象。

# 字节对齐的原则是什么？

- 从偏移为0的位置开始存储；
- 如果没有定义`#pragma pack(n)`
    - `sizeof`的最终结果必然是结构内部最大成员的整数倍，不够补齐；
    - 结构内部各个成员的首地址必然是自身大小的整数倍；
- 如果定义了`#pragma pack(n)`
    - `sizeof`的最终结果必然必然是`min[n,结构内部最大成员]`的整数倍，不够补齐；
    - 结构内部各个成员的首地址必然是`min[n,自身大小]`的整数倍。

# 在C++中，使用malloc申请的内存能否通过delete释放？使用new申请的内存能否用free？

不能。

malloc /free主要为了兼容C，new和delete 完全可以取代malloc /free的。malloc /free的操作对象都是必须明确大小的。

而且不能用在动态类上。new 和delete会自动进行类型检查和，也不需要自己明确内存大小，malloc/free不能执行构造函数与析构函数，所以动态对象它是不行的。

当然从理论上说使用malloc申请的内存是可以通过delete释放的。不过一般不这样写的。而且也不能保证每个C++的运行时都能正常。
# 正确释放vector的内存(clear(), swap(), shrink_to_fit())

vec.clear()：清空内容，但是不释放内存。

vector().swap(vec)：清空内容，且释放内存，想得到一个全新的vector。

vec.shrink_to_fit()：请求容器降低其capacity和size匹配。

vec.clear();vec.shrink_to_fit();：清空内容，且释放内存。

# 什么是右值引用

[理解 C/C++ 中的左值和右值 | nettee 的 blog](https://nettee.github.io/posts/2018/Understanding-lvalues-and-rvalues-in-C-and-C/)

![image](https://cdn.staticaly.com/gh/andyye1999/picx-images-hosting@master/20230626/image.6guct2ckun00.png)