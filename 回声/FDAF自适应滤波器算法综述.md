# [自适应滤波器算法综述以及代码实现](https://www.cnblogs.com/LXP-Never/p/11773190.html)  
## 频域分块LMS(FDAF)

　　在讲频域分块LMS之前建议大家回顾一个时域分块LMS算法

时域分块LMS：

e(n+m)=d(n+m)−XT(n+m)w(n)

w(k+1)=w(k)+μ∑i=0L−1X(kL+i)e(kL+i)

Block  LMS的误差计算 和 权重更新公式中，

y(n+m)=XT(n+m)w(n)：是输入向量与滤波器系数向量的**线性卷积**

∇^(k)=−∑i=0L−1X(kL+i)e(kL+i)：是误差信号与输入向量的**线性相关**

对于线性卷积和线性相关的运算量较大，特别是在

　　当回声路径很长且复杂，并且回声延迟较高时，时域自适应滤波算法中的**线性卷积**和**线性相关**运算量较大，导致计算复杂度升高，我们更愿意把这两个信号变换到频域，**通过频域相乘的方式来取代时域复杂度相当高的卷积或相关运算**。所以我们把时域自适应滤波算法，衍生到频域自适应滤波算法。
# 预备知识：
  
 **线性卷积（相关）和圆周卷积（相关）之间的关系**
1.  一般的，如果两个有限长序列的长度为N1和N2，且满足N1≥N2，则有**圆周卷积**的**后** N1−N2+1个点，与**线性卷积**的结果一致。
2.  一般的，如果两个有限长序列的长度为N1和N2，且满足N1≥N2，则有**圆周相关**的**前** N1−N2+1个点，与**线性相关**的结果一致。
3.  时域中的**圆周卷积**对应于其**离散傅里叶变换的乘积**
4.  时域中的**圆周相关**对应于其**离散傅里叶变换共轭谱的乘积 **
因此我们需要将 分块LMS自适应滤波算法中的**线性卷积**和**线性相关** 通过快速傅里叶变换(FFT)转换到频域来实现。这样实现的分块LMS自适应滤波算法称为**频域块LMS自适应滤波算法**(**FDAF**，Frequency-Domain Block Least Mean Square Adaptive Filter)。FDAF算法将长度为L的自适应滤波器分成FFT长度的整数倍个子块，对输入信号的每个子块进行频域内的LMS算法。

**第一步：计算线性卷积**

y(n+m)=XT(n+m)w(n)

利用FFT计算线性卷积的方法有：

-   重叠存储法（overlap save method，更常用）
-   重叠相加法（overlap add method）

　　我们这里以overlap save method为例，为了确保能得到N个点的线性卷积输出信号，我们至少要保证有N个点的线性卷积和圆周卷积的结果一致（预备知识）

N1−N2+1=N

由于N1≥N2 (输入信号长度通常大于滤波器的阶数)，且N2=N (滤波器的阶数为N)，那么要求每次参与运算的输入信号长度N1至少为2N−1，为了计算FFT方便，我们令输入信号的长度为：N1=2N，那么我们FFT的长度也为2N

　　为了构造长度为2N的数据，我们需要在每个N阶滤波器后面N补零

![](https://img2020.cnblogs.com/blog/1433301/202012/1433301-20201227172619795-855301426.png)

　　要 求线性卷积(预备知识1)，我们就需要 求圆周卷积后N1−N2+1个点，根据预备知识3，我们只需要求 离散傅里叶变换的乘积 就能得到圆周卷积的结果，接下来我们分别计算 输入信号向量 和 滤波器系数向量 的FFT：

X(k)=diag{F[x(kN−N),…,x(kN−1),|x(kN),…,x(kN+N−1))]}

W(k)=F[WT(k),|0,…,0]T

频域相乘

Y(k)=X(k)W(k)

则，N点线性卷积输出信号y(k)=[y(kN),y(kN+1),...,y(kN+N−1)]，就等于Y(k)的傅里叶逆变换的后N个点：y(k)=last N samples of F−1Y(k)

![](https://img2020.cnblogs.com/blog/1433301/202012/1433301-20201227174555219-1330640721.png)

图: overlap save 切片法

**第二步：计算线性相关**

∇^(k)=−∑i=0L−1X(kL+i)e(kL+i)

　　根据预备知识2，4可知，需要求线性相关，我们可以通过获得 圆周相关 来获得。因此我们需要**求输入信号的共轭谱与误差信号谱的乘积**。

输入信号X(k)在上一步处理卷积运算是已经求得。

那么，剩下的工作就是，将误差向量e(k)=[e(kN),e(kN+1),...,e(kN+N−1)]也扩展到2N长度，因为是求**相关**，我们需要在误差向量**前面补0**，然后经过FFT：E(k)=F[0,0,…,0,eT(k)]T

频域相乘：

Δ(k)=X∗(k)E(k)

最后，将梯度向量进行傅里叶逆变换∇→(k)=F−1Δ(k)，取前N个点，就是我们求的线性相关。

**第三步：滤波器系数更新**

W(k+1)=W(k)+μF[∇→T(k),0,0,…,0]T

注意：

-   第一，滤波器系数直接在频域更新，所以需要将梯度向量再次变换到频域；
-   第二，由于滤波器系数向量后面补了N 个零 ，为了保证结果的正确性梯度向量也需要在后面补 N 个零。

![](https://img2020.cnblogs.com/blog/1433301/202104/1433301-20210415135132014-882186624.png)

基于重叠存储法的频域块LMS自适应滤波算法的信号流程图

![](https://img2018.cnblogs.com/blog/1433301/201911/1433301-20191103221551679-266669524.png)

![Fdaf_1](https://cdn.jsdelivr.net/gh/andyye1999/image-hosting@master/20220524/Fdaf_1.3sdj2wyg79m0.webp)
![Fdaf_2](https://cdn.jsdelivr.net/gh/andyye1999/image-hosting@master/20220524/Fdaf_2.13rl1h2ucvs0.webp)
![Fdaf_3](https://cdn.jsdelivr.net/gh/andyye1999/image-hosting@master/20220524/Fdaf_3.5smgfvptcjg0.webp)